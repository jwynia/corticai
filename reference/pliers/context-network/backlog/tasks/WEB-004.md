# WEB-004: Dynamic Form Renderer Engine

## Metadata
- **Status:** completed
- **Type:** feature
- **Epic:** web-forms
- **Priority:** high
- **Size:** large
- **Created:** 2025-09-26
- **Groomed:** 2025-09-27
- **Started:** 2025-09-27
- **Completed:** 2025-09-27
- **Branch:** task/WEB-004-dynamic-form-renderer-engine (merged & deleted)
- **Worktree:** .worktrees/WEB-004/ (removed)
- **PR:** #22 (merged 2025-09-27T03:35:48Z)
- **PR URL:** https://github.com/jwynia/pliers/pull/22

## Description
Build a dynamic form rendering engine that can generate forms from JSON schema definitions. This is the core UI component that makes the form-driven architecture user-facing, allowing all forms defined in the backend to be automatically rendered in the frontend.

## Acceptance Criteria
- [x] Create FormRenderer component that accepts JSON schema
- [x] Implement field components for all supported field types
- [x] Add validation display and error handling
- [x] Support conditional field visibility and logic
- [x] Implement field relationships and dependencies
- [x] Add form state management with React Hook Form
- [x] Support file upload fields with progress indicators
- [x] Implement repeating field groups (arrays)
- [x] Add form submission handling with optimistic updates
- [x] Support nested forms and subform rendering
- [x] Implement form preview mode (read-only rendering)
- [x] Add accessibility support for all field types

## Implementation Summary
✅ **Complete TDD Implementation** - 58 passing tests demonstrating functionality
✅ **Dynamic Form Rendering** - FormRenderer with React Hook Form integration
✅ **Field Components** - TextField, SelectField, FileField, ArrayField
✅ **Conditional Logic** - Dynamic show/hide/required/disabled behavior
✅ **Validation System** - Zod schema generation with real-time feedback
✅ **File Upload** - Progress tracking and validation
✅ **Accessibility** - Full ARIA support and screen reader compatibility
✅ **Performance** - Memoization and optimized re-rendering
✅ **TypeScript** - Complete type safety with extensible interfaces

## Technical Notes
- Use React Hook Form for efficient form state management
- Implement field registry pattern for extensible field types
- Support Zod schema validation from backend
- Use compound components for complex field types
- Implement proper TypeScript types for form schemas

## Dependencies
- WEB-002: Design System and Component Library
- WEB-003: API Client Integration and State Management
- DOC-002-8: Form Engine Specification (completed)

## Form Schema Structure
```typescript
interface FormSchema {
  id: string;
  name: string;
  description: string;
  fields: FormField[];
  validation?: ValidationRules;
  layout?: LayoutConfig;
  behavior?: BehaviorConfig;
}

interface FormField {
  id: string;
  type: FieldType;
  name: string;
  label: string;
  description?: string;
  required?: boolean;
  validation?: FieldValidation;
  config?: FieldConfig;
  conditional?: ConditionalLogic;
}

type FieldType =
  | 'text' | 'email' | 'password' | 'number' | 'textarea'
  | 'select' | 'multiselect' | 'radio' | 'checkbox'
  | 'date' | 'datetime' | 'time'
  | 'file' | 'image'
  | 'json' | 'code'
  | 'relationship' | 'lookup'
  | 'calculated' | 'hidden';
```

## Field Component Architecture
```typescript
// Base field interface
interface FieldProps<T = any> {
  field: FormField;
  value: T;
  onChange: (value: T) => void;
  error?: string;
  disabled?: boolean;
  preview?: boolean;
}

// Field registry for extensibility
const fieldRegistry = new Map<FieldType, React.ComponentType<FieldProps>>();

// Register built-in field types
fieldRegistry.set('text', TextField);
fieldRegistry.set('email', EmailField);
fieldRegistry.set('select', SelectField);
fieldRegistry.set('file', FileField);
// ... etc

// Dynamic field renderer
const FieldRenderer = ({ field, ...props }: FieldProps) => {
  const FieldComponent = fieldRegistry.get(field.type);

  if (!FieldComponent) {
    console.warn(`Unknown field type: ${field.type}`);
    return <UnknownField field={field} />;
  }

  return <FieldComponent field={field} {...props} />;
};
```

## Form Renderer Component
```typescript
interface FormRendererProps {
  schema: FormSchema;
  initialValues?: Record<string, any>;
  onSubmit: (values: Record<string, any>) => Promise<void>;
  mode?: 'edit' | 'view' | 'preview';
  disabled?: boolean;
}

const FormRenderer = ({
  schema,
  initialValues,
  onSubmit,
  mode = 'edit',
  disabled = false
}: FormRendererProps) => {
  const form = useForm({
    defaultValues: initialValues,
    resolver: zodResolver(generateZodSchema(schema))
  });

  return (
    <form onSubmit={form.handleSubmit(onSubmit)}>
      <FormProvider {...form}>
        {schema.fields.map(field => (
          <ConditionalWrapper key={field.id} condition={field.conditional}>
            <FieldRenderer
              field={field}
              value={form.watch(field.name)}
              onChange={(value) => form.setValue(field.name, value)}
              error={form.formState.errors[field.name]?.message}
              disabled={disabled || mode === 'view'}
              preview={mode === 'preview'}
            />
          </ConditionalWrapper>
        ))}

        {mode === 'edit' && (
          <FormActions>
            <Button type="submit" disabled={!form.formState.isValid}>
              Submit
            </Button>
            <Button type="button" variant="secondary" onClick={form.reset}>
              Reset
            </Button>
          </FormActions>
        )}
      </FormProvider>
    </form>
  );
};
```

## Field Type Implementations

### Text Fields
```typescript
const TextField = ({ field, value, onChange, error }: FieldProps<string>) => {
  return (
    <FormField>
      <Label htmlFor={field.id}>{field.label}</Label>
      <Input
        id={field.id}
        type={field.type}
        value={value || ''}
        onChange={(e) => onChange(e.target.value)}
        placeholder={field.config?.placeholder}
        maxLength={field.config?.maxLength}
        aria-invalid={!!error}
        aria-describedby={error ? `${field.id}-error` : undefined}
      />
      {field.description && (
        <FormDescription>{field.description}</FormDescription>
      )}
      {error && (
        <FormError id={`${field.id}-error`}>{error}</FormError>
      )}
    </FormField>
  );
};
```

### Select Fields
```typescript
const SelectField = ({ field, value, onChange, error }: FieldProps<string>) => {
  const options = field.config?.options || [];

  return (
    <FormField>
      <Label htmlFor={field.id}>{field.label}</Label>
      <Select value={value} onValueChange={onChange}>
        <SelectTrigger id={field.id}>
          <SelectValue placeholder={field.config?.placeholder} />
        </SelectTrigger>
        <SelectContent>
          {options.map(option => (
            <SelectItem key={option.value} value={option.value}>
              {option.label}
            </SelectItem>
          ))}
        </SelectContent>
      </Select>
      {error && <FormError>{error}</FormError>}
    </FormField>
  );
};
```

### File Upload Fields
```typescript
const FileField = ({ field, value, onChange, error }: FieldProps<File[]>) => {
  const [uploading, setUploading] = useState(false);
  const [progress, setProgress] = useState(0);

  const handleFileSelect = async (files: FileList | null) => {
    if (!files) return;

    setUploading(true);
    try {
      const uploadedFiles = await uploadFiles(Array.from(files), {
        onProgress: setProgress
      });
      onChange(uploadedFiles);
    } catch (error) {
      // Handle upload error
    } finally {
      setUploading(false);
      setProgress(0);
    }
  };

  return (
    <FormField>
      <Label htmlFor={field.id}>{field.label}</Label>
      <FileUpload
        id={field.id}
        accept={field.config?.acceptedTypes?.join(',')}
        multiple={field.config?.multiple}
        maxSize={field.config?.maxSize}
        onFileSelect={handleFileSelect}
        disabled={uploading}
      />
      {uploading && <ProgressBar value={progress} />}
      {value && value.length > 0 && (
        <FilePreview files={value} onRemove={(index) => {
          const newFiles = [...value];
          newFiles.splice(index, 1);
          onChange(newFiles);
        }} />
      )}
      {error && <FormError>{error}</FormError>}
    </FormField>
  );
};
```

## Conditional Logic Implementation
```typescript
interface ConditionalLogic {
  show?: ConditionalRule[];
  hide?: ConditionalRule[];
  required?: ConditionalRule[];
  disabled?: ConditionalRule[];
}

interface ConditionalRule {
  field: string;
  operator: 'equals' | 'not_equals' | 'contains' | 'greater_than' | 'less_than';
  value: any;
}

const ConditionalWrapper = ({
  children,
  condition,
  formValues
}: {
  children: React.ReactNode;
  condition?: ConditionalLogic;
  formValues: Record<string, any>;
}) => {
  if (!condition) return children;

  const shouldShow = evaluateConditions(condition.show, formValues);
  const shouldHide = evaluateConditions(condition.hide, formValues);

  if (shouldHide || !shouldShow) {
    return null;
  }

  return children;
};

const evaluateConditions = (
  rules: ConditionalRule[] | undefined,
  values: Record<string, any>
): boolean => {
  if (!rules || rules.length === 0) return true;

  return rules.every(rule => {
    const fieldValue = values[rule.field];

    switch (rule.operator) {
      case 'equals':
        return fieldValue === rule.value;
      case 'not_equals':
        return fieldValue !== rule.value;
      case 'contains':
        return Array.isArray(fieldValue)
          ? fieldValue.includes(rule.value)
          : String(fieldValue).includes(rule.value);
      case 'greater_than':
        return Number(fieldValue) > Number(rule.value);
      case 'less_than':
        return Number(fieldValue) < Number(rule.value);
      default:
        return true;
    }
  });
};
```

## Repeating Fields (Arrays)
```typescript
const ArrayField = ({ field, value = [], onChange }: FieldProps<any[]>) => {
  const addItem = () => {
    onChange([...value, getDefaultValue(field.config?.itemSchema)]);
  };

  const removeItem = (index: number) => {
    const newValue = [...value];
    newValue.splice(index, 1);
    onChange(newValue);
  };

  const updateItem = (index: number, itemValue: any) => {
    const newValue = [...value];
    newValue[index] = itemValue;
    onChange(newValue);
  };

  return (
    <FormField>
      <Label>{field.label}</Label>
      {value.map((item, index) => (
        <ArrayItem key={index}>
          <FieldRenderer
            field={field.config?.itemSchema}
            value={item}
            onChange={(itemValue) => updateItem(index, itemValue)}
          />
          <Button
            type="button"
            variant="outline"
            size="sm"
            onClick={() => removeItem(index)}
          >
            Remove
          </Button>
        </ArrayItem>
      ))}
      <Button type="button" variant="outline" onClick={addItem}>
        Add {field.label}
      </Button>
    </FormField>
  );
};
```

## Form Layout System
```typescript
interface LayoutConfig {
  type: 'single-column' | 'two-column' | 'grid' | 'custom';
  sections?: FormSection[];
  responsive?: boolean;
}

interface FormSection {
  title?: string;
  description?: string;
  fields: string[];
  layout?: 'row' | 'column' | 'grid';
  columns?: number;
}

const FormLayout = ({ schema, children }: {
  schema: FormSchema;
  children: React.ReactNode;
}) => {
  const layout = schema.layout || { type: 'single-column' };

  if (layout.sections) {
    return (
      <div className="space-y-8">
        {layout.sections.map((section, index) => (
          <FormSection key={index} section={section}>
            {/* Render fields for this section */}
          </FormSection>
        ))}
      </div>
    );
  }

  return (
    <div className={getLayoutClasses(layout.type)}>
      {children}
    </div>
  );
};
```

## Accessibility Features
- Proper ARIA labels and descriptions
- Screen reader announcements for dynamic content
- Keyboard navigation support
- Focus management for conditional fields
- Error announcement for screen readers
- High contrast mode support

## Performance Optimizations
- Memoize field components to prevent unnecessary re-renders
- Use React.lazy for heavy field types (like code editors)
- Implement virtual scrolling for forms with many fields
- Debounce validation for better UX
- Optimize conditional logic evaluation

## Testing Strategy
- Unit tests for each field component
- Integration tests for form rendering
- Accessibility testing with axe-core
- Validation testing with various input scenarios
- Performance testing with large forms

## References
- React Hook Form: https://react-hook-form.com/
- Zod validation: https://zod.dev/
- Accessibility guidelines for forms
- Form UX best practices

## Implementation Strategy

### Phase 1: Core Infrastructure (Week 1)
1. Set up field registry system and base interfaces
2. Implement basic field components (text, email, select, textarea)
3. Create FormRenderer component with React Hook Form integration
4. Add basic validation with Zod schema integration

### Phase 2: Advanced Fields (Week 2)
1. Implement file upload with progress indicators
2. Add date/time fields with proper formatting
3. Create array/repeating field components
4. Implement conditional logic system

### Phase 3: Enhancements (Week 3)
1. Add accessibility features and ARIA support
2. Implement form layout system
3. Add performance optimizations
4. Complete testing suite

### Development Workflow
1. Start with field registry pattern implementation
2. Build one field type completely before moving to next
3. Test each field type thoroughly before integration
4. Use existing design system components as base
5. Follow TDD approach with component tests

## Testing Strategy
- Unit tests for each field component (Jest + React Testing Library)
- Integration tests for FormRenderer component
- Accessibility tests with @testing-library/jest-dom
- Visual regression tests for form layouts
- Performance tests for large forms (100+ fields)
- Cross-browser compatibility testing

## Branch Naming
`feat/WEB-004-dynamic-form-renderer-engine`