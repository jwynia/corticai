# SEC-009: Implement Proper Token Revocation Storage

## Metadata
- **Status:** ready
- **Type:** improvement
- **Epic:** security-hardening
- **Priority:** medium
- **Size:** medium
- **Created:** 2025-09-24
- **Branch:** task/SEC-009-token-storage

## Description
The current token revocation implementation uses a Set that could grow unbounded, causing memory leaks. Need to implement proper storage with automatic expiration, possibly using an LRU cache or Redis.

## Acceptance Criteria
- [ ] Replace unbounded Set with proper storage solution:
  - Option A: LRU cache with configurable size (10,000 default)
  - Option B: Redis with TTL if available
  - Fallback: Enhanced in-memory with cleanup
- [ ] Implement automatic expiration:
  - Tokens expire based on their JWT exp claim
  - Additional safety buffer of 5 minutes
  - Cleanup runs every 60 seconds
- [ ] Add monitoring and limits:
  - Maximum 10,000 revoked tokens in memory
  - Log warnings at 80% capacity
  - Export metrics: total revoked, expired, evicted
- [ ] Performance requirements:
  - O(1) lookup time for isRevoked check
  - < 10ms for revoke operation
  - < 100MB memory for 10,000 tokens

## Technical Notes
- Current issue in `websocket-auth.ts:556-564`
- Simple cleanup at 1000 tokens is inadequate
- Options to consider:
  - LRU cache with TTL
  - Redis with automatic expiration
  - In-memory cache with periodic cleanup
  - Track token expiry times

## Dependencies
- SEC-004: WebSocket Authentication (completed)

## Implementation Notes
```typescript
// Example LRU approach:
class TokenRevocationStore {
  private cache: LRUCache<string, boolean>;

  constructor(maxSize = 10000, ttl = 3600000) {
    this.cache = new LRUCache({
      max: maxSize,
      ttl: ttl
    });
  }

  revoke(token: string, expiresAt?: number) {
    const ttl = expiresAt ? expiresAt - Date.now() : undefined;
    this.cache.set(token, true, { ttl });
  }

  isRevoked(token: string): boolean {
    return this.cache.has(token);
  }
}
```

## Testing Strategy
- Memory tests:
  - Add 10,000 tokens, measure memory usage
  - Verify memory is freed after expiration
  - Test memory limits are enforced
  - Run for 24 hours, check for leaks
- Functionality tests:
  - Token revocation persists until expiry
  - Expired tokens are cleaned up
  - LRU eviction works correctly
  - Metrics are accurate
- Performance tests:
  - 10,000 isRevoked checks/second
  - 1,000 revoke operations/second
  - Cleanup doesn't block operations
- Edge cases:
  - Tokens without exp claim
  - Already expired tokens
  - Duplicate revocations
  - Clock skew scenarios

## Implementation Approach
```typescript
import LRU from 'lru-cache';

class TokenRevocationStore {
  private cache: LRU<string, number>; // token -> expiry timestamp
  private metrics = {
    totalRevoked: 0,
    expired: 0,
    evicted: 0
  };

  constructor(options = {}) {
    this.cache = new LRU({
      max: options.maxSize || 10000,
      ttl: options.defaultTTL || 3600000, // 1 hour default
      updateAgeOnGet: false,
      dispose: (key, value, reason) => {
        if (reason === 'evict') this.metrics.evicted++;
        if (reason === 'expire') this.metrics.expired++;
      }
    });

    // Periodic cleanup every minute
    setInterval(() => this.cleanup(), 60000);
  }

  revoke(token: string, payload?: JWTPayload): void {
    const expiry = payload?.exp ? payload.exp * 1000 : Date.now() + 3600000;
    const ttl = Math.max(0, expiry - Date.now() + 300000); // +5 min buffer

    this.cache.set(token, expiry, { ttl });
    this.metrics.totalRevoked++;

    if (this.cache.size > this.cache.max * 0.8) {
      logger.warn('Token revocation cache at 80% capacity');
    }
  }

  isRevoked(token: string): boolean {
    return this.cache.has(token);
  }

  private cleanup(): void {
    // LRU handles TTL automatically, this is for additional cleanup if needed
    const now = Date.now();
    for (const [token, expiry] of this.cache.entries()) {
      if (expiry < now) {
        this.cache.delete(token);
        this.metrics.expired++;
      }
    }
  }

  getMetrics() {
    return {
      ...this.metrics,
      currentSize: this.cache.size,
      maxSize: this.cache.max
    };
  }
}
```

## Branch Naming
`task/SEC-009-token-revocation-storage`

## Effort Estimate
- Implementation: 3-4 hours
- Testing: 2-3 hours
- Documentation: 30 minutes