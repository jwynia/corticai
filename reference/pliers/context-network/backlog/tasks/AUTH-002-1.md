# AUTH-002-1: Magic Link Token Infrastructure

## Metadata
- **Status:** ready
- **Type:** feature
- **Epic:** passwordless-authentication
- **Priority:** high
- **Size:** small
- **Estimated Effort:** 2-3 days
- **Created:** 2025-10-01
- **Parent Task:** AUTH-002 (archived - oversized)
- **Branch:** feat/AUTH-002-1-magic-link-token-infrastructure

## Description
Implement the core token infrastructure for magic link authentication, including cryptographically secure token generation, database schema for token storage, and token verification services. This provides the foundation for all magic link functionality.

## Acceptance Criteria
- [ ] Implement secure token generation using crypto.randomBytes (256+ bits)
- [ ] Create database schema for magic_tokens table with proper indexes
- [ ] Implement token creation service with hashing (SHA-256)
- [ ] Implement token verification service with hash comparison
- [ ] Enforce single-use tokens with used_at timestamp

## Technical Notes
- Tokens must be 256+ bit cryptographically secure
- Store hashed tokens only, never plaintext in database
- Token expiration: 5-15 minutes based on action type
- Use constant-time comparison for hash verification
- Database indexes optimized for lookup and cleanup queries

## Implementation Approach

### Token Generation
```typescript
import crypto from 'crypto';

interface MagicLinkToken {
  id: string;           // UUID
  userId: string;       // Associated user ID
  action: 'login' | 'register'; // Action type
  expiresAt: Date;      // 5-15 minute expiration
  usedAt?: Date;        // Single-use enforcement
  tokenHash: string;    // Hashed token (SHA-256)
  metadata: {
    ipAddress?: string; // Optional IP binding
    userAgent?: string; // Optional UA binding
  };
}

const generateSecureToken = (): string => {
  // Generate 32 bytes (256 bits) of cryptographically secure random data
  return crypto.randomBytes(32).toString('base64url');
};

const hashToken = (token: string): string => {
  return crypto.createHash('sha256').update(token).digest('hex');
};

class MagicLinkTokenService {
  async createToken(
    userId: string,
    action: 'login' | 'register',
    expirationMinutes: number = 10,
    metadata?: { ipAddress?: string; userAgent?: string }
  ): Promise<{ token: string; tokenRecord: MagicLinkToken }> {
    const token = generateSecureToken();
    const tokenHash = hashToken(token);

    const expiresAt = new Date();
    expiresAt.setMinutes(expiresAt.getMinutes() + expirationMinutes);

    const tokenRecord = await db.magicTokens.create({
      userId,
      action,
      tokenHash,
      expiresAt,
      metadata: metadata || {}
    });

    // Return the plaintext token (only time it's available)
    return { token, tokenRecord };
  }

  async verifyToken(token: string): Promise<MagicLinkToken | null> {
    const tokenHash = hashToken(token);

    const tokenRecord = await db.magicTokens.findOne({
      tokenHash,
      expiresAt: { $gt: new Date() },
      usedAt: null
    });

    if (!tokenRecord) {
      return null;
    }

    // Use constant-time comparison for security
    const isValid = crypto.timingSafeEqual(
      Buffer.from(tokenHash),
      Buffer.from(tokenRecord.tokenHash)
    );

    return isValid ? tokenRecord : null;
  }

  async markTokenAsUsed(tokenId: string): Promise<void> {
    await db.magicTokens.update(
      { id: tokenId },
      { usedAt: new Date() }
    );
  }
}
```

### Database Schema
```sql
CREATE TABLE magic_tokens (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  token_hash TEXT UNIQUE NOT NULL,
  action_type VARCHAR(50) NOT NULL CHECK (action_type IN ('login', 'register')),
  expires_at TIMESTAMP NOT NULL,
  used_at TIMESTAMP NULL,
  created_at TIMESTAMP DEFAULT NOW(),
  metadata JSONB DEFAULT '{}'
);

CREATE INDEX idx_magic_tokens_hash ON magic_tokens(token_hash);
CREATE INDEX idx_magic_tokens_cleanup ON magic_tokens(expires_at) WHERE used_at IS NULL;
CREATE INDEX idx_magic_tokens_user ON magic_tokens(user_id);
```

## Dependencies
- AUTH-001: Authentication Infrastructure Foundation

## Follows After
- AUTH-001: Authentication Infrastructure Foundation

## Enables
- AUTH-002-2: Email Delivery and Templates
- AUTH-002-3: Magic Link Verification and Rate Limiting

## Testing Strategy
- Unit tests for token generation (verify length, randomness)
- Unit tests for hash creation and verification
- Security tests for token collision resistance
- Database migration tests (up and down)
- Test single-use enforcement
- Test expiration handling
- Performance tests for token generation speed

## Success Metrics
- Tokens are cryptographically secure (256+ bits)
- Hash verification works correctly with constant-time comparison
- Single-use enforcement prevents token reuse
- Database queries are performant with proper indexes
- No plaintext tokens stored in database

## Security Considerations
- Use crypto.randomBytes for token generation (not Math.random)
- Hash tokens before database storage (SHA-256 minimum)
- Use constant-time comparison to prevent timing attacks
- Store minimal metadata to reduce data exposure
- Implement proper cleanup for expired tokens

## Branch Naming
`feat/AUTH-002-1-magic-link-token-infrastructure`
