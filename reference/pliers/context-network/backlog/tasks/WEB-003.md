# WEB-003: API Client Integration and State Management

## Metadata
- **Status:** completed
- **Type:** feature
- **Epic:** web-foundation
- **Priority:** high
- **Size:** medium
- **Created:** 2025-09-26
- **Updated:** 2025-09-27
- **Completed:** 2025-09-27
- **Branch:** feat/WEB-003-api-client-state-management (merged)
- **PR:** #20 (merged)
- **PR URL:** https://github.com/jwynia/pliers/pull/20
- **Merged By:** jwynia

## Description
Set up React Query (TanStack Query) for server state management and integrate with the Pliers API client. This provides efficient data fetching, caching, and synchronization between the frontend and backend.

## Acceptance Criteria
- [ ] Install and configure React Query v5 (@tanstack/react-query)
- [ ] Set up React Query DevTools for development environment
- [ ] Create type-safe API client service with fetch (no axios dependency)
- [ ] Implement JWT token management with automatic refresh
- [ ] Set up hierarchical query key factory pattern
- [ ] Implement retry logic with exponential backoff (max 3 retries)
- [ ] Create custom hooks for forms, submissions, and user operations
- [ ] Add optimistic updates for form creation and submission
- [ ] Implement background refetching with 5-minute stale time
- [ ] Set up WebSocket integration for real-time form updates
- [ ] Add authentication interceptors with 401 handling
- [ ] Implement cache persistence with localStorage fallback
- [ ] Write unit tests for API client and custom hooks (80%+ coverage)
- [ ] Add integration tests for error scenarios and offline behavior

## Technical Notes
- Use React Query for all server state management
- Implement proper query key management for cache invalidation
- Use TypeScript for API response type safety
- WebSocket integration for real-time form data updates
- Proper error boundaries for API failures

## Dependencies
- ✅ WEB-001: React SPA Foundation with Vite (ready)
- ✅ AUTH-001: Authentication Infrastructure Foundation (ready)
- ✅ IMPL-003: Authentication and Authorization System (ready)

## Prerequisites
- Node.js 22+ and npm 10+ installed
- Vite development server running
- API server available at localhost:3001

## API Client Architecture
```typescript
// API service structure
class ApiClient {
  private baseURL: string;
  private authToken: string | null = null;

  async request<T>(endpoint: string, options?: RequestInit): Promise<T> {
    // Implement with proper error handling and auth
  }

  // Domain-specific methods
  auth = {
    login: (credentials: LoginRequest) => this.request('/auth/login', ...),
    refresh: () => this.request('/auth/refresh', ...),
    logout: () => this.request('/auth/logout', ...)
  };

  forms = {
    list: () => this.request('/forms', ...),
    get: (id: string) => this.request(`/forms/${id}`, ...),
    create: (form: FormData) => this.request('/forms', ...),
    update: (id: string, form: FormData) => this.request(`/forms/${id}`, ...)
  };

  submissions = {
    list: (formId: string) => this.request(`/forms/${formId}/submissions`, ...),
    create: (formId: string, data: SubmissionData) => this.request(`/forms/${formId}/submissions`, ...),
    get: (formId: string, submissionId: string) => this.request(`/forms/${formId}/submissions/${submissionId}`, ...)
  };
}
```

## Query Key Factory Pattern
```typescript
const queryKeys = {
  all: ['api'] as const,
  forms: () => [...queryKeys.all, 'forms'] as const,
  form: (id: string) => [...queryKeys.forms(), id] as const,
  formSubmissions: (formId: string) => [...queryKeys.form(formId), 'submissions'] as const,

  users: () => [...queryKeys.all, 'users'] as const,
  user: (id: string) => [...queryKeys.users(), id] as const,

  dashboard: () => [...queryKeys.all, 'dashboard'] as const,
  dashboardData: (widgetId: string) => [...queryKeys.dashboard(), widgetId] as const
};
```

## Custom Hooks for API Operations
```typescript
// Form-related hooks
export const useForm = (formId: string) => {
  return useQuery({
    queryKey: queryKeys.form(formId),
    queryFn: () => apiClient.forms.get(formId),
    enabled: !!formId
  });
};

export const useCreateForm = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: apiClient.forms.create,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: queryKeys.forms() });
    },
    onError: (error) => {
      // Error handling
    }
  });
};

// Submission-related hooks
export const useFormSubmissions = (formId: string) => {
  return useQuery({
    queryKey: queryKeys.formSubmissions(formId),
    queryFn: () => apiClient.submissions.list(formId),
    enabled: !!formId
  });
};

export const useCreateSubmission = (formId: string) => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (data: SubmissionData) => apiClient.submissions.create(formId, data),
    onMutate: async (newSubmission) => {
      // Optimistic update
      await queryClient.cancelQueries({ queryKey: queryKeys.formSubmissions(formId) });

      const previousSubmissions = queryClient.getQueryData(queryKeys.formSubmissions(formId));

      queryClient.setQueryData(queryKeys.formSubmissions(formId), old => [
        ...(old || []),
        { ...newSubmission, id: 'temp-' + Date.now(), status: 'pending' }
      ]);

      return { previousSubmissions };
    },
    onError: (err, newSubmission, context) => {
      queryClient.setQueryData(queryKeys.formSubmissions(formId), context?.previousSubmissions);
    },
    onSettled: () => {
      queryClient.invalidateQueries({ queryKey: queryKeys.formSubmissions(formId) });
    }
  });
};
```

## Error Handling Strategy
```typescript
interface ApiError {
  message: string;
  code: string;
  status: number;
  details?: Record<string, any>;
}

const ErrorBoundary = ({ children }: { children: React.ReactNode }) => {
  return (
    <QueryErrorResetBoundary>
      {({ reset }) => (
        <ErrorBoundaryComponent
          onReset={reset}
          fallbackRender={({ error, resetErrorBoundary }) => (
            <ErrorFallback error={error} onRetry={resetErrorBoundary} />
          )}
        >
          {children}
        </ErrorBoundaryComponent>
      )}
    </QueryErrorResetBoundary>
  );
};
```

## Authentication Integration
```typescript
const useAuthToken = () => {
  const [token, setToken] = useState<string | null>(
    localStorage.getItem('auth_token')
  );

  const setAuthToken = (newToken: string | null) => {
    if (newToken) {
      localStorage.setItem('auth_token', newToken);
      apiClient.setAuthToken(newToken);
    } else {
      localStorage.removeItem('auth_token');
      apiClient.clearAuthToken();
    }
    setToken(newToken);
  };

  return { token, setAuthToken };
};
```

## WebSocket Integration
```typescript
const useWebSocketSubscription = (endpoint: string) => {
  const queryClient = useQueryClient();

  useEffect(() => {
    const ws = new WebSocket(endpoint);

    ws.onmessage = (event) => {
      const data = JSON.parse(event.data);

      // Update relevant queries based on event type
      switch (data.type) {
        case 'form.submission.created':
          queryClient.invalidateQueries({
            queryKey: queryKeys.formSubmissions(data.formId)
          });
          break;
        case 'form.updated':
          queryClient.invalidateQueries({
            queryKey: queryKeys.form(data.formId)
          });
          break;
      }
    };

    return () => ws.close();
  }, [endpoint, queryClient]);
};
```

## React Query Configuration
```typescript
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000, // 5 minutes
      cacheTime: 10 * 60 * 1000, // 10 minutes
      retry: (failureCount, error) => {
        if (error.status === 404) return false;
        return failureCount < 3;
      },
      refetchOnWindowFocus: false
    },
    mutations: {
      retry: 1
    }
  }
});
```

## Offline Support
```typescript
const useOfflineManager = () => {
  const queryClient = useQueryClient();

  useEffect(() => {
    const handleOnline = () => {
      queryClient.resumePausedMutations();
      queryClient.invalidateQueries();
    };

    const handleOffline = () => {
      // Pause background refetching
    };

    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);

    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, [queryClient]);
};
```

## Performance Considerations
- Implement request deduplication
- Use background refetching for better UX
- Implement proper cache invalidation strategies
- Optimize query key structures for selective invalidation
- Use parallel queries where appropriate

## Security Considerations
- Secure token storage and transmission
- Implement proper CSRF protection
- Sanitize API responses before caching
- Handle authentication errors gracefully
- Implement request/response logging for security monitoring

## Testing Strategy
- Mock API responses for component tests
- Test error scenarios and retry logic
- Verify optimistic updates work correctly
- Test WebSocket integration
- Test offline/online scenarios

## References
- React Query documentation: https://tanstack.com/query/
- API design best practices
- WebSocket integration patterns
- React error boundary patterns

## Testing Strategy
- Mock API responses using MSW (Mock Service Worker)
- Test optimistic updates and rollback scenarios
- Test offline/online state transitions
- Test WebSocket connection and disconnection
- Test authentication token refresh flows
- Test error boundaries and fallback components
- Performance testing for large data sets

## Package Requirements
```json
{
  "@tanstack/react-query": "^5.0.0",
  "@tanstack/react-query-devtools": "^5.0.0"
}
```

## Branch Naming
`feat/WEB-003-api-client-state-management`