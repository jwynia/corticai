# SEC-010: Implement getActiveSubscriptions Method

## Metadata
- **Status:** ready
- **Type:** feature
- **Epic:** websocket-features
- **Priority:** medium
- **Size:** small
- **Created:** 2025-09-24
- **Branch:** task/SEC-010-active-subscriptions

## Description
The `getActiveSubscriptions()` method in WebSocketAuthHandler is currently a placeholder returning an empty array. Need to implement proper tracking of active subscriptions per connection.

## Acceptance Criteria
- [ ] Implement subscription tracking:
  - Store in Map<connectionId, SubscriptionInfo[]>
  - Track: eventType, userId, filters, subscribedAt
  - Automatic cleanup on WebSocket close
- [ ] Implement getActiveSubscriptions() with options:
  - Filter by userId
  - Filter by organizationId
  - Filter by eventType pattern
  - Include/exclude inactive connections
- [ ] Add subscription limits:
  - Max 100 subscriptions per connection
  - Max 1000 total subscriptions per server
  - Configurable via environment variables
- [ ] Add analytics/metrics:
  - Total active subscriptions
  - Subscriptions per user
  - Most subscribed event types
  - Average subscription duration
- [ ] Add admin endpoints:
  - GET /api/admin/websocket/subscriptions
  - DELETE /api/admin/websocket/subscriptions/:connectionId

## Technical Notes
- Placeholder at `websocket-auth.ts:567-570`
- Need to track in AuthenticatedWebSocket.subscriptions
- Consider subscription limits per user
- May need subscription validation

## Dependencies
- SEC-004: WebSocket Authentication (completed)

## Implementation Notes
```typescript
// Track subscriptions properly:
interface SubscriptionInfo {
  eventType: string;
  userId: string;
  subscribedAt: Date;
  lastActivity?: Date;
}

class WebSocketAuthHandler {
  private activeSubscriptions = new Map<string, SubscriptionInfo[]>();

  trackSubscription(ws: AuthenticatedWebSocket, eventType: string) {
    const userId = ws.user.id;
    if (!this.activeSubscriptions.has(userId)) {
      this.activeSubscriptions.set(userId, []);
    }
    this.activeSubscriptions.get(userId)!.push({
      eventType,
      userId,
      subscribedAt: new Date()
    });
  }

  getActiveSubscriptions(userId?: string): SubscriptionInfo[] {
    if (userId) {
      return this.activeSubscriptions.get(userId) || [];
    }
    return Array.from(this.activeSubscriptions.values()).flat();
  }
}
```

## Testing Strategy
- Subscription lifecycle tests:
  - Subscribe to multiple event types
  - Verify subscriptions are tracked
  - Unsubscribe and verify removal
  - Disconnect and verify cleanup
- Filtering tests:
  - Filter by userId returns only user's subscriptions
  - Filter by organizationId works across users
  - Pattern matching (e.g., 'user.*') works
  - Multiple filters combine correctly
- Limit enforcement tests:
  - Cannot exceed 100 subscriptions per connection
  - Server limit of 1000 is enforced
  - Proper error messages on limit exceeded
- Performance tests:
  - 1000 connections with 10 subscriptions each
  - Memory usage stays under 50MB
  - getActiveSubscriptions() < 10ms
- Admin endpoint tests:
  - List all subscriptions via API
  - Force disconnect specific connection
  - Proper authorization required

## Implementation Approach
```typescript
interface SubscriptionInfo {
  eventType: string;
  userId: string;
  organizationId?: string;
  connectionId: string;
  subscribedAt: Date;
  lastActivity: Date;
  filters?: Record<string, unknown>;
}

interface GetSubscriptionsOptions {
  userId?: string;
  organizationId?: string;
  eventTypePattern?: string;
  includeInactive?: boolean;
}

class SubscriptionManager {
  private subscriptions = new Map<string, SubscriptionInfo[]>();
  private userIndex = new Map<string, Set<string>>(); // userId -> connectionIds
  private limits = {
    perConnection: parseInt(process.env.WS_MAX_SUBS_PER_CONNECTION || '100'),
    total: parseInt(process.env.WS_MAX_TOTAL_SUBS || '1000')
  };

  subscribe(
    ws: AuthenticatedWebSocket,
    eventType: string,
    filters?: Record<string, unknown>
  ): void {
    const connectionId = ws.id;
    const userId = ws.user.id;

    // Check limits
    const connectionSubs = this.subscriptions.get(connectionId) || [];
    if (connectionSubs.length >= this.limits.perConnection) {
      throw new Error(`Subscription limit (${this.limits.perConnection}) exceeded`);
    }

    const totalSubs = Array.from(this.subscriptions.values())
      .reduce((sum, subs) => sum + subs.length, 0);
    if (totalSubs >= this.limits.total) {
      throw new Error(`Server subscription limit (${this.limits.total}) exceeded`);
    }

    // Add subscription
    const sub: SubscriptionInfo = {
      eventType,
      userId,
      organizationId: ws.user.organizationId,
      connectionId,
      subscribedAt: new Date(),
      lastActivity: new Date(),
      filters
    };

    if (!this.subscriptions.has(connectionId)) {
      this.subscriptions.set(connectionId, []);
    }
    this.subscriptions.get(connectionId)!.push(sub);

    // Update indexes
    if (!this.userIndex.has(userId)) {
      this.userIndex.set(userId, new Set());
    }
    this.userIndex.get(userId)!.add(connectionId);
  }

  getActiveSubscriptions(options: GetSubscriptionsOptions = {}): SubscriptionInfo[] {
    let results: SubscriptionInfo[] = [];

    if (options.userId) {
      const connectionIds = this.userIndex.get(options.userId) || new Set();
      for (const connId of connectionIds) {
        results.push(...(this.subscriptions.get(connId) || []));
      }
    } else {
      results = Array.from(this.subscriptions.values()).flat();
    }

    // Apply filters
    if (options.organizationId) {
      results = results.filter(s => s.organizationId === options.organizationId);
    }

    if (options.eventTypePattern) {
      const pattern = new RegExp(options.eventTypePattern.replace('*', '.*'));
      results = results.filter(s => pattern.test(s.eventType));
    }

    return results;
  }

  cleanup(connectionId: string): void {
    const subs = this.subscriptions.get(connectionId) || [];
    for (const sub of subs) {
      const userConnections = this.userIndex.get(sub.userId);
      if (userConnections) {
        userConnections.delete(connectionId);
        if (userConnections.size === 0) {
          this.userIndex.delete(sub.userId);
        }
      }
    }
    this.subscriptions.delete(connectionId);
  }

  getMetrics() {
    const allSubs = Array.from(this.subscriptions.values()).flat();
    const eventTypeCounts = new Map<string, number>();

    for (const sub of allSubs) {
      eventTypeCounts.set(sub.eventType, (eventTypeCounts.get(sub.eventType) || 0) + 1);
    }

    return {
      totalSubscriptions: allSubs.length,
      totalConnections: this.subscriptions.size,
      totalUsers: this.userIndex.size,
      topEventTypes: Array.from(eventTypeCounts.entries())
        .sort((a, b) => b[1] - a[1])
        .slice(0, 10),
      limits: this.limits
    };
  }
}
```

## Branch Naming
`task/SEC-010-subscription-tracking`

## Effort Estimate
- Implementation: 3-4 hours
- Testing: 2 hours
- Admin endpoints: 1 hour
- Documentation: 30 minutes